<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>面试官初体验 | Kevinello</title><meta name="keywords" content="Golang,后台开发,数据库,Docker,Kubenetes,网络,并发编程,虚拟化,动态规划,Redis,面试,Java,位运算"><meta name="author" content="Kevinello"><meta name="copyright" content="Kevinello"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 近期作为后台开发面试官整理的一些简单面试题（仅供参考仅供参考仅供参考  基础题  Golang   Golang中函数调用是传值还是传引用 golang中所有函数参数传递都是传值，slice、map和chan看上去像传引用只是因为他们内部有指针或本身就是指针而已；slice结构体里有一个指向底层数组array的指针，所以slice在作为函数参数传递进去的时候，虽然和map以及chan一样可"><meta property="og:type" content="article"><meta property="og:title" content="面试官初体验"><meta property="og:url" content="http://kevinello.ltd/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/index.html"><meta property="og:site_name" content="Kevinello"><meta property="og:description" content="前言 近期作为后台开发面试官整理的一些简单面试题（仅供参考仅供参考仅供参考  基础题  Golang   Golang中函数调用是传值还是传引用 golang中所有函数参数传递都是传值，slice、map和chan看上去像传引用只是因为他们内部有指针或本身就是指针而已；slice结构体里有一个指向底层数组array的指针，所以slice在作为函数参数传递进去的时候，虽然和map以及chan一样可"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png"><meta property="article:published_time" content="2022-01-10T04:59:10.000Z"><meta property="article:modified_time" content="2022-04-09T15:54:59.593Z"><meta property="article:author" content="Kevinello"><meta property="article:tag" content="Golang"><meta property="article:tag" content="后台开发"><meta property="article:tag" content="数据库"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Kubenetes"><meta property="article:tag" content="网络"><meta property="article:tag" content="并发编程"><meta property="article:tag" content="虚拟化"><meta property="article:tag" content="动态规划"><meta property="article:tag" content="Redis"><meta property="article:tag" content="面试"><meta property="article:tag" content="Java"><meta property="article:tag" content="位运算"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png"><link rel="shortcut icon" href="/imgs/K.jpg"><link rel="canonical" href="http://kevinello.ltd/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d2a20aecba22b2eaf60183c4831d9a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RV8K5FBVX5"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RV8K5FBVX5")</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"13UJR6CRNO","apiKey":"456e56f51ec27a1e13d67bef144f6747","indexName":"Kevinello_blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试官初体验",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-09 23:54:59"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2232093_k6128tldgy.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/11/myself-e3fde6.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kevinello</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试官初体验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-10T04:59:10.000Z" title="发表于 2022-01-10 12:59:10">2022-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-09T15:54:59.593Z" title="更新于 2022-04-09 23:54:59">2022-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试官初体验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>近期作为后台开发面试官整理的一些简单面试题（<strong>仅供参考仅供参考仅供参考</strong></p><h2 id="基础题"><a class="markdownIt-Anchor" href="#基础题"></a> 基础题</h2><h3 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> Golang</h3><ol><li><p>Golang中函数调用是传值还是传引用</p><p><strong>golang中所有函数参数传递都是传值</strong>，<code>slice</code>、<code>map</code>和<code>chan</code>看上去像传引用只是因为他们内部有指针或本身就是指针而已；<code>slice</code>结构体里有一个指向底层数组array的指针，所以<code>slice</code>在作为函数参数传递进去的时候，虽然和<code>map</code>以及<code>chan</code>一样可以修改其中的值，但是内部<code>slice</code>若使用append之类的方法修改了大小，则这部分长度信息的变化不会反馈到外层<code>slice</code>中，甚至会因为底层数组扩容（<code>cap</code>扩充）导致内外<code>slice</code>指向了不同的底层数组；而<code>map</code>和<code>chan</code>因为本质上就是指针，故所有函数内的变动都会反馈到外面，除非在函数内部改变了这些指针指向的内存（这也是<code>map</code>和<code>chan</code>的<code>copy</code>的实现方法）</p></li><li><p>Golang中<code>make</code>和<code>new</code>的区别？</p><ul><li><code>make</code> 只能用来分配及初始化类型为 <code>slice</code>、<code>map</code>、<code>chan</code>的数据，<code>new</code>可以分配任意类型的数据</li><li><code>new</code> 分配返回的是指针，即类型 <code>*Type</code>。<code>make</code> 返回引用，即 Type</li><li><code>new</code> 分配的空间被清零；<strong><code>make</code> 分配空间后，会进行初始化</strong></li></ul></li><li><p>以下程序输出为？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    mymap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        mymap[index] = &amp;value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> mymap &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;map[%v]: %v\n&quot;</span>, key, *value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">3</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">0</span>]=<span class="number">3</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">3</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>因为<code>for range</code>创建了迭代对象每个元素的副本，而不是直接返回每个元素的引用，如果使用该值变量的地址作为指向每个元素的指针，就会导致错误，在迭代时，返回的变量是<strong>同一个</strong>迭代过程中根据切片依次赋值的变量，所以最终<code>map</code>中存储的地址都是同一个变量的地址，而<strong>其值即为最后一次迭代中赋的值</strong></p></li><li><p>以下程序输出为？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Print(nums[i])</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">333</span><br></pre></td></tr></table></figure><p>每轮循环启动一个协程，而协程启动与循环变量递增不是在同一个协程，协程启动的速度远小于循环执行的速度，所以即使是第一个协程刚起启动时，循环变量可能已经递增完毕。由于所有的协程共享循环变量i，而且这个i会在最后一个使用它的协程结束后被销毁，所以最后输出结果时<code>i</code>是循环变量的末值即<code>2</code>，输出的都是<code>nums[2]</code></p><p>要想正确地打印<code>nums</code>内的元素，我们可以这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Print(nums[i])</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>以下程序的输出是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">uint64</span> = <span class="number">10</span></span><br><span class="line">atomic.AddUint64(&amp;b,<span class="number">-3</span>)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><p>实际上这样写会使 Go 语言的编译器报错：</p><blockquote><p>constant -3 overflows uint64</p></blockquote><p>因为这样的运算溢出了</p><p>要正确的做这样的运算我们需要：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">uint64</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int64</span> = <span class="number">-3</span></span><br><span class="line">atomic.AddUint64(&amp;b, <span class="keyword">uint64</span>(c))</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure></li><li><p>go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</p><p>阅读以下程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a return:&quot;</span>, a())</span><br><span class="line">        fmt.Println(<span class="string">&quot;b return:&quot;</span>, b())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                i++</span><br><span class="line">                fmt.Println(<span class="string">&quot;defer:&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                i++</span><br><span class="line">                fmt.Println(<span class="string">&quot;defer:&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                i++</span><br><span class="line">                fmt.Println(<span class="string">&quot;defer:&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                i++</span><br><span class="line">                fmt.Println(<span class="string">&quot;defer:&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a defer: ?</span><br><span class="line">a defer: ?</span><br><span class="line">a return: ?</span><br><span class="line">b defer: ?</span><br><span class="line">b defer: ?</span><br><span class="line">b return: ?</span><br><span class="line">c defer: ?</span><br><span class="line">c defer: ?</span><br><span class="line">c return: ?</span><br></pre></td></tr></table></figure><p>实际输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a defer: 1</span><br><span class="line">a defer: 2</span><br><span class="line">a return: 0</span><br><span class="line">b defer: 1</span><br><span class="line">b defer: 2</span><br><span class="line">b return: 2</span><br><span class="line">c defer: 1</span><br><span class="line">c defer: 2</span><br><span class="line">c return: 2</span><br></pre></td></tr></table></figure><ol><li>多个defer的执行顺序为“后进先出”，栈的形式</li><li>defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出</li></ol><p>返回值不同的原因：</p><blockquote><p><code>a()int</code> 函数的返回值没有被提前声明，其值来自于其他变量的赋值，而defer中修改的也是其他变量，而非返回值本身，因此函数退出时返回值并没有被改变</p><p><code>b()(i int)</code> 函数的返回值被提前声明，也就意味着defer中是可以调用到真实返回值的，因此defer在return赋值返回值 i 之后，再一次地修改了 i 的值，最终函数退出后的返回值才会是defer修改过的值</p><p><code>c()*int</code> 的返回值虽然没有被提前声明，但是由于 <code>c()*int</code> 的返回值是指针变量，那么在return将变量 i 的地址赋给返回值后，defer再次修改了 i 在内存中的实际值，因此函数退出时返回值虽然依旧是原来的指针地址，但是其指向的内存实际值已经被成功修改了</p></blockquote></li><li><p>Golang 中的<code>interface</code>是什么？</p><p>go里面的interface分为两种：不带接口的eface和带接口的的iface</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20211221141603.png" alt="img"></p><p>eface只包含两个成员变量，分别是 指向interface类型信息结构体的指针和指向interface所包含的值的空间的指针</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20211221141608.png" alt="img"></p><p>iface包含两部分，itab结构和data结构。data结构与eface中的data结构一样，指向的是interface的值。itab结构中包含了interfacetype指针指向了该interface的静态类型，也就是该interface的类型，比如上文提到的TestInterface这个interface，以及这个interface所包含的方法集。itab的_type字段指向了该iface的动态类型类型，也就是我们把一个实现了该interface所有方法的interface赋值给当前interface的类型。fun字段指向了这个动态类型的函数集，这个函数集是大于静态类型的interface的方法集的。因为它可能包含自己一些另外的方法集。这些函数的集合以字母数序表做排序。至于为何这是一个动态数组，系统位数确定的情况下，函数指针大小是 固定的，往后照着排就可以了</p></li><li><p>反射是什么？Golang中的反射是基于什么实现的？</p><p>在编译时不知道类型的情况下，通过反射机制可以获取对象的类型、值、方法甚至动态改变对象的成员，这就是反射机制</p><p>Golang Reflection 三大法则：</p><ol><li><strong>Reflection goes from interface value to reflection object</strong></li><li><strong>Reflection goes from reflection object to interface value</strong></li><li><strong>To modify a reflection object, the value must be settable</strong></li></ol><p>总而言之，Golang中的反射是基于<code>interface</code>实现的，因为任意类型都实现了<code>interface&#123;&#125;</code>类型，所以可以把任意类型的变量转换成<code>interface&#123;&#125;</code>类型，所以反射能从<code>interface&#123;&#125;</code>的数据结构中反射出对象，也就是利用reflect.ValueOf和reflect.TypeOf从interface反射出对象的具体信息</p></li><li><p>以下程序会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	v.SetInt(<span class="number">24</span>)</span><br><span class="line">	<span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会<code>Panic</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect: reflect.Value.SetInt using unaddressable value</span><br></pre></td></tr></table></figure><p>对应 Reflection 三大法则的第三条，要修改一个反射对象，它的值必须是能修改的；简单点说，就是通过反射，必须反射出它的本身，而不是它的一份拷贝</p><p>传入<code>reflect.ValueOf()</code>的x只是x的一个拷贝，对v的修改反应不到x本身上，所以会panic</p><p>那怎么反射出它的本身，和我们函数传参的时候很像：地址；将上文的<code>v := reflect.ValueOf(x)</code>改为<code>v := reflect.ValueOf(&amp;x).Elem()</code>即可，如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line">	v := reflect.ValueOf(&amp;x).Elem()</span><br><span class="line">	v.SetInt(<span class="number">24</span>)</span><br><span class="line">	<span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>已关闭的channel再次读取会出现什么现象？</p></li></ol><p>closed channel是可以被消费者继续读取的，在读完了有意义的数据之后，将读到一堆空值</p><ol start="11"><li><p>如何判断一个<code>channel</code>已关闭？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中ch是一个只读的channel，因为&lt;-ch左侧没有接收者，所以如果channel没有关闭，<code>case &lt;-ch</code>就会被阻塞，又因为select中写了default语句，所以select会直接执行default的空分支，最终return false；如果channel关闭了，<code>case &lt;-ch</code>就不会被阻塞，直接执行该分支return true</p></li><li><p>map 循环是有序的还是无序的？</p><p>无序的</p></li></ol><h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3><ol><li><p>ArrayList和LinkedList的区别</p><ol><li><p>数据的更新和查找</p><p>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p></li><li><p>数据的增加和删除</p><p>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下</p></li></ol></li><li><p>HashMap 和 HashTable 区别</p><p>最大的区别：</p><ol><li><p>HashMap 不是线程安全的</p><p>HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许</p></li><li><p>HashTable 是线程安全 Collection</p><p>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable</p></li></ol><p>其它区别如下：</p><ul><li>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li><li>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</li><li>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</li><li>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</li><li>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</li></ul></li><li><p>List接口、Set接口和Map接口的区别</p><p>Collection表示一组对象,这些对象也称为collection的元素;一些 collection允许有重复的元素,而另一些则不允许;一些collection是有序的,而另一些则是无序的;JDK中不提供此接口的任何直接实 现,它提供更具体的子接口(如 Set 和 List)实现;Map没有继承Collection接口,Map提供key到value的映射;一个Map中不能包含相同key,每个key只能映射一个value;Map接口提供3种集合的视图,Map的内容可以被当做一组key集合,一组value集合,或者一组key-value映射</p></li><li><p>Java线程间的通信方式</p><ol><li><p>wait()方法</p><p>wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。</p><p>当前的线程必须拥有当前对象的monitor，也即lock，就是锁。</p><p>线程调用wait()方法，释放它对锁的拥有权，然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。</p><p>要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。</p><p>一个小比较：</p><p>当线程调用了wait()方法时，它会释放掉对象的锁。</p><p>另一个会导致线程暂停的方法：Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。</p></li><li><p>notify()方法</p><p>notify()方法会唤醒一个等待当前对象的锁的线程。</p><p>如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）。</p><p>被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁。</p><p>被唤醒的线程将和其他线程以通常的方式进行竞争，来获得对象的锁。也就是说，被唤醒的线程并没有什么优先权，也没有什么劣势，对象的下一个线程还是需要通过一般性的竞争。</p><p>notify()方法应该是被拥有对象的锁的线程所调用。</p><p>(This method should only be called by a thread that is the owner of this object’s monitor)</p><p>换句话说，和wait()方法一样，notify方法调用必须放在synchronized方法或synchronized块中。</p><p>wait()和notify()方法要求在调用时线程已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。</p><p>一个线程变为一个对象的锁的拥有者是通过下列三种方法：</p><ol><li>执行这个对象的synchronized实例方法。</li><li>执行这个对象的synchronized语句块。这个语句块锁的是这个对象。</li><li>对于Class类的对象，执行那个类的synchronized、static方法。</li></ol></li></ol></li><li><p>判断对象是垃圾 ?</p><p>有两种经典的判断方法：</p><ul><li><p>引用计数法，思路很简单，但是如果出现循环引用，即：A 引用 B，B 又引用 A，这种情况下就不好办了，所以 JVM 中使用了另一种称为“可达性分析”的判断方法</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/5730cbe92c7b18b703ec25cced784feb-75fd23.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>可达性分析法</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/16456a32e56133a848752b8ece9ce201-4479e1-7ae5b2.png" alt="img"></p></li></ul></li><li><p>如果 A 引用 B，B 又引用 A，这 2 个对象是否能被 GC 回收？</p><p>关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots 没有关联，则会被回收，否则将继续存活。</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/0e93fb1a4ded082105a42ce3083c1870-8416df.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上图是一个用“可达性分析”标记垃圾对象的示例图，灰色的对象表示不可达对象，将等待回收。</p></li><li><p>常用的 GC 算法</p><ol><li><p>mark-sweep 标记清除法</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/7c5cfe28cf47c791b84a687ffa1c11af-cd6c1d.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如上图，黑色区域表示待清理的垃圾对象，标记出来后直接清空。该方法简单快速，但是缺点也很明显，会产生很多内存碎片</p></li><li><p>mark-copy 标记复制法</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/262523a518bcf925cc161aa6444cac30-274d4c.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>思路也很简单，将内存对半分，总是保留一块空着（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧，然后左侧全部清空。避免了内存碎片问题，但是内存浪费很严重，相当于只能使用 50%的内存。</p></li><li><p>mark-compact 标记-整理（也称标记-压缩）法</p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/4c7fa2074cfeae304dd10f140e2ba6b0-f2be23.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>避免了上述两种算法的缺点，将垃圾对象清理掉后，同时将剩下的存活对象进行整理挪动（类似于 windows 的磁盘碎片整理），保证它们占用的空间连续，这样就避免了内存碎片问题，但是整理过程也会降低 GC 的效率。</p></li></ol></li><li><p>equals()和 ==的区别</p><p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    //this - s1</span><br><span class="line">    //obj - s2</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。<br>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。</p><p>我们对上面的两段内容做个总结吧：</p><p><strong>== 的作用：</strong><br>　基本类型：比较的就是值是否相同<br>　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　引用类型：默认情况下，比较的是地址值。<br>注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</p></li></ol><h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3><ol><li><p>redis<strong>事务</strong>满足关系性数据库事务的特性吗</p><p><code>Redis</code>事务仅具有一致性与隔离性，不保证原子性和持久性</p></li><li><p><strong>zset</strong>的实现原理（或者说数据结构）</p></li><li><p>redis中<strong>pipeline</strong>的作用</p><p>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回，主要作用是减少与<code>redis server</code>的IO次数，减少网络IO消耗</p></li><li><p>LRU 和 LFU 是？</p><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常用于页面置换算法，为虚拟页式存储管理服务。</p></li><li><p>分布式锁的基本实现以及坑（展开到进阶实现）</p><p><strong>基于 Redis 的 <code>NX EX</code> 参数</strong></p><p>利用 <code>Redis set key</code> 的 NX 参数来保证在这个 key 不存在的情况下写入成功，并且再加上 EX 参数设置过期时间</p><p>进阶：</p><ul><li><p><strong>A进程释放了B进程的锁</strong><br>如果进程 A 获取了锁设置了超时时间，但是由于<strong>执行周期较长</strong>导致到了超时时间之后锁就自动释放了。这时进程 B 获取了该锁，然而这时进程 A 执行完了，释放了该锁；这样就会出现进程 A 将进程 B 的锁释放了<br>所以最好的方式是在每次解锁时都需要判断锁<strong>是否是自己</strong>的（生成uuid放到value中）</p></li><li><p><strong>锁过期了，业务还没执行完</strong><br>设置<code>看门狗</code>，在业务执行时自动延长锁的过期时间（<strong>举例子</strong>：假如加锁的时间是30秒，过10秒检查一次，一旦加锁的业务没有执行完，就会进行一次续期，把锁的过期时间再次重置成30秒）</p></li><li><p>redis 主从复制导致锁丢失<br>在分布式redis中，主节点没来的及把<strong>刚刚set进来这条数据</strong>给从节点，就挂了，这就造成了redis异步复制造成的锁丢失<br>使用<code>RedLock</code>：红锁算法认为，只要n/2+1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。 流程为：</p><ol><li>顺序向五个节点请求加锁</li><li>根据一定的<strong>超时时间</strong>来推断是不是跳过该节点</li><li>三个节点加锁成功并且花费时间小于锁的有效期</li><li>认定加锁成功</li></ol></li></ul></li><li><p>Redis的内存碎片是什么？Redis的内存碎片清理机制是什么？</p><h4 id="产生内存碎片的主要原因"><a class="markdownIt-Anchor" href="#产生内存碎片的主要原因"></a> 产生内存碎片的主要原因：</h4><ul><li><code>redis</code>自己实现的内存分配器：在<code>redis</code>中新建<code>key-value</code>值时，<code>redis</code>需要向操作系统申请内存，一般的进程在不需要使用申请的内存后，会直接释放掉、归还内存；但<code>redis</code>不一样，<code>redis</code>在使用完内存后并不会直接归还内存，而是放在<code>redis</code>自己实现的内存分配器中管理，这样就不需要每次都向操作系统申请内存了，实现了高性能（但这样其它应用可就不高兴了，自私的Redis）</li><li><code>value</code>的更新：<code>redis</code>的每个<code>key-value</code>对初始化的内存大小是最适合的，当这个<code>value</code>改变的并且原来内存大小不适用的时候，就需要重新分配内存了，重新分配之后，就会有一部分内存<code>redis</code>无法正常回收，一直占用着</li></ul><h4 id="如何清理内存碎片"><a class="markdownIt-Anchor" href="#如何清理内存碎片"></a> 如何清理内存碎片？</h4><h5 id="redis版本40以下"><a class="markdownIt-Anchor" href="#redis版本40以下"></a> Redis版本4.0以下</h5><p>重启<code>redis</code>，自动归还所有内存，简单粗暴</p><h5 id="redis版本40以上"><a class="markdownIt-Anchor" href="#redis版本40以上"></a> Redis版本4.0以上</h5><p>可以开启自动内存碎片清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEXT</span><br><span class="line">127.0.0.1:6379[6]&gt; config set activedefrag yes</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>自动内存清理的一些相关配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TEXT</span><br><span class="line"># Enabled active defragmentation</span><br><span class="line"># 碎片整理总开关</span><br><span class="line"># activedefrag yes</span><br><span class="line"></span><br><span class="line"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"># 内存碎片达到多少的时候开启整理</span><br><span class="line">active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"># Minimum percentage of fragmentation to start active defrag</span><br><span class="line"># 碎片率达到百分之多少开启整理</span><br><span class="line">active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"># 碎片率小余多少百分比开启整理</span><br><span class="line">active-defrag-threshold-upper 100</span><br></pre></td></tr></table></figure><p>当然，在面对一些复杂的场景时我们希望能根据自己设计的策略来进行内存碎片清理，<code>redis</code>也提供了手动内存碎片清理的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEXT</span><br><span class="line">127.0.0.1:6379&gt; memory purge</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ol><h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3><ol><li><p>如何用Mysql实现分布式锁</p><p>创建一张锁表，然后通过操作该表中的数据来实现加锁和解锁。当要锁住某个方法或资源时，就向该表插入一条记录，表中设置方法名为唯一键，这样多个请求同时提交数据库时，只有一个操作可以成功，判定操作成功的线程获得该方法的锁，可以执行方法内容；想要释放锁的时候就删除这条记录，其他线程就可以继续往数据库中插入数据获取锁</p></li><li><p>什么是触发器？触发器的使用场景有哪些?</p><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码</p><p>使用场景</p><p>可以通过数据库中的相关表实现级联更改。<br>实时监控某张表中的某个字段的更改而需要做出相应的处理。<br>例如可以生成某些业务的编号。<br>注意不要滥用，否则会造成数据库及应用程序的维护困难。<br>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别</p></li><li><p>MySQL中都有哪些触发器?</p><p>在MySQL数据库中有如下六种触发器：</p><p>Before Insert<br>After Insert<br>Before Update<br>After Update<br>Before Delete<br>After Delete</p></li><li><p>SQL 约束有哪几种？</p><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。<br>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。<br>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。<br>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。<br>CHECK: 用于控制字段的值范围</p></li><li><p>六种关联查询</p><p>交叉连接（CROSS JOIN）<br>内连接（INNER JOIN）<br>外连接（LEFT JOIN/RIGHT JOIN）<br>联合查询（UNION与UNION ALL）<br>全连接（FULL JOIN）<br>交叉连接（CROSS JOIN）<br>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p></li><li><p>内连接分为三类</p><p>等值连接：ON <a target="_blank" rel="noopener" href="http://A.id=B.id">A.id=B.id</a><br>不等值连接：ON <a target="_blank" rel="noopener" href="http://A.id">A.id</a> &gt; <a target="_blank" rel="noopener" href="http://B.id">B.id</a><br>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid<br>外连接（LEFT JOIN/RIGHT JOIN）</p><p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN<br>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p></li><li><p>varchar与char的区别</p><p>char的特点</p><p>char表示定长字符串，长度是固定的；</p><p>如果插入数据的长度小于char的固定长度时，则用空格填充；</p><p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p><p>对于char来说，最多能存放的字符个数为255，和编码无关</p><p>varchar的特点</p><p>varchar表示可变长字符串，长度是可变的；</p><p>插入的数据是多长，就按照多长来存储；</p><p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p><p>对于varchar来说，最多能存放的字符个数为65532</p></li><li><p>索引有哪几种类型？</p><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</p><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</p><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</p><p>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</p><p>全文索引： 是目前搜索引擎使用的一种关键技术。</p><p>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</p></li></ol><h3 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h3><ol><li><p>讲讲Nginx负载均衡</p><ul><li>轮询、轮询是默认的，每一个请求按顺序逐一分配到不同的后端服务器，如果后端服务器down掉了，则能自动剔除</li><li>ip_hash、个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li><li>weight、weight是设置权重，用于后端服务器性能不均的情况，访问比率约等于权重之比</li><li>fair(第三方)、这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li><li>url_hash(第三方)此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li></ul></li><li><p>正向代理，反向代理是什么？</p><p><strong>正向代理</strong>，也就是传说中的代理, 简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p><strong>反向代理</strong>： 结论就是，反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p></li><li><p>Cookie和Session的区别</p><p>cookie和session都是用来跟踪浏览器用户身份的会话方式</p><p>区别：</p><ul><li>cookie数据保存在客户端，session数据保存在服务器端。简单的说，当你登录一个网站的时候, 如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</li><li>sessionid是服务器和客户端链接时候随机分配的. 如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。</li></ul><p>如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器</p><p>两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。</p><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。</p></li><li><p>csrf攻击是什么？常见的防御手段有什么？</p><p><strong>跨站点请求伪造</strong></p><p>简单来说就是<strong>通过伪装成受信任用户的请求来利用受信任的网站</strong></p><blockquote><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行</p></blockquote><h4 id="防御手段"><a class="markdownIt-Anchor" href="#防御手段"></a> 防御手段：</h4><ul><li>验证HTTP Referer字段</li><li>在请求地址中添加token并验证</li><li>在HTTP头中自定义属性并验证</li></ul></li><li><p>请说明一下http和https的区别</p><p>https协议要申请证书到ca，需要一定经济成本；2） http是明文传输，https是加密的安全传输；3） 连接的端口不一样，http是80，https是443；4）http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全</p></li><li><p>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</p><p>1.DNS解析</p><p>2.TCP连接</p><p>3.发送HTTP请求</p><p>4.服务器处理请求并返回HTTP报文</p><p>5.浏览器解析渲染页面</p></li></ol><h3 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h3><ol><li><p>悲观锁</p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p></li><li><p>乐观锁</p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的</p></li><li><p>两种锁的使用场景</p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><p>读的多，冲突几率小，乐观锁。<br>写的多，冲突几率大，悲观锁。</p></li></ol><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h3><ol><li><p>docker多层构建镜像的意义</p><p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，<strong>能够将前置阶段中的文件拷贝到后边的阶段中</strong>，这就是多阶段构建的最大意义</p><p>最大的使用场景是将<strong>编译环境和运行环境分离</strong></p></li><li><p>讲讲docker网络模式（bridge, host）</p><p>Docker 默认提供了 5 种网络驱动模式</p><ul><li><strong>bridge</strong>: 默认的网络驱动模式。如果不指定驱动程序，bridge 便会作为默认的网络驱动模式。当应用程序运行在需要通信的独立容器 (standalone containers) 中时，通常会选择 bridge 模式</li><li>host：移除容器和 Docker 宿主机之间的网络隔离，并<strong>直接使用主机的网络</strong>。host 模式仅适用于 Docker 17.06+</li><li>overlay：overlay 网络将多个 Docker 守护进程连接在一起，并使集群服务能够相互通信。您还可以使用 overlay 网络来实现 swarm 集群和独立容器之间的通信，或者不同 Docker 守护进程上的两个独立容器之间的通信。该策略实现了在这些容器之间进行操作系统级别路由的需求</li><li>macvlan：Macvlan 网络允许为容器分配 MAC 地址，使其显示为网络上的物理设备。 Docker 守护进程通过其 MAC 地址将流量路由到容器。对于希望直连到物理网络的传统应用程序而言，使用 macvlan 模式一般是最佳选择，而不应该通过 Docker 宿主机的网络进行路由</li><li>none：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none 模式不适用于集群服务</li></ul></li><li><p>如何在一个<strong>自定义ip</strong>上运行docker容器？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.18.0.0/16 mynetwork // 创建自定义网络，指定子网段</span><br><span class="line">docker run -itd --name networkTest --net mynetwork --ip 172.18.0.2 centos:latest /bin/bash // 使用该网络创建容器，并在该网段上指定ip</span><br></pre></td></tr></table></figure></li><li><p>dockerFile中最常见的指令是什么?</p><ul><li>COPY 复制文件</li><li>ADD 更高级的复制文件</li><li>CMD 容器启动命令</li><li>ENTRYPOINT 入口点</li><li>ENV 设置环境变量</li><li>ARG 构建参数</li><li>VOLUME 定义匿名卷</li><li>EXPOSE 暴露端口</li></ul><p>ADD和COPY的区别：</p><p>ADD可以完成COPY的所有工作，ADD还可以很方便的解压文件</p></li><li><p>Docker的常用命今?</p></li><li><p>如何临时退出一个正在交互的容器的终端，而不终止它？</p></li><li><p>什么是docker-compose?</p></li><li><p>如何退出容器时候自动删除?</p></li></ol><h3 id="kubenetes"><a class="markdownIt-Anchor" href="#kubenetes"></a> Kubenetes</h3><ol><li>简述Kubernetes和Docker的关系?</li><li>Kubernetes中的相关基础概念（deployment,service,pod,job等）</li><li>简述Kubernetes中Pod的健康检查方式</li></ol><h2 id="现场算法题"><a class="markdownIt-Anchor" href="#现场算法题"></a> 现场算法题</h2><h3 id="子集78"><a class="markdownIt-Anchor" href="#子集78"></a> 子集(78)</h3><p><code>Tag</code>: 位运算 / 回溯</p><h4 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong> ，返回该数组所有可能的子集（幂集）</p><p>解集<strong>不能</strong>包含重复的子集，你可以按<strong>任意顺序</strong>返回解集</p><h4 id="时间要求"><a class="markdownIt-Anchor" href="#时间要求"></a> 时间要求</h4><p>15 min</p><h4 id="输入输出示例"><a class="markdownIt-Anchor" href="#输入输出示例"></a> 输入输出示例</h4><ul><li><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p></blockquote></li><li><p>示例 2：</p><blockquote><p>输入：nums = [0]<br>输出：[[],[0]]</p></blockquote></li></ul><h4 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h4><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h4 id="参考代码"><a class="markdownIt-Anchor" href="#参考代码"></a> 参考代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="string">`make`</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> position := <span class="number">0</span>; position &lt; <span class="number">1</span>&lt;&lt;length; position++ &#123;</span><br><span class="line">        subset := <span class="string">`make`</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> position&amp;(<span class="number">1</span>&lt;&lt;j) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                subset = <span class="built_in">append</span>(subset, nums[j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, subset)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="top-k215"><a class="markdownIt-Anchor" href="#top-k215"></a> TOP K(215)</h3><p><code>Tag</code>: 分治 / 堆</p><h4 id="题目要求-2"><a class="markdownIt-Anchor" href="#题目要求-2"></a> 题目要求</h4><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素</p><h4 id="时间要求-2"><a class="markdownIt-Anchor" href="#时间要求-2"></a> 时间要求</h4><p>20 min</p><h4 id="输入输出示例-2"><a class="markdownIt-Anchor" href="#输入输出示例-2"></a> 输入输出示例</h4><ul><li><p>示例 1：</p><blockquote><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p></blockquote></li><li><p>示例 2：</p><blockquote><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote></li></ul><h4 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2"></a> 提示</h4><ul><li>1 &lt;= k &lt;= nums.length &lt;= 104</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul><h4 id="参考代码-2"><a class="markdownIt-Anchor" href="#参考代码-2"></a> 参考代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(nums []<span class="keyword">int</span>, left, right, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index := randomPartition(nums, left, right); index == k<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> index &gt; k<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, left, index<span class="number">-1</span>, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, index+<span class="number">1</span>, right, k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(nums []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    randomIndex := (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    nums[randomIndex], nums[right] = nums[right], nums[randomIndex]</span><br><span class="line">    pivot := nums[right]</span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt; right; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; pivot &#123;</span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="口答算法题"><a class="markdownIt-Anchor" href="#口答算法题"></a> 口答算法题</h2><h3 id="判断一个链表是否有环如何找到这个环的起点"><a class="markdownIt-Anchor" href="#判断一个链表是否有环如何找到这个环的起点"></a> 判断一个链表是否有环，如何找到这个环的起点</h3><p><strong>给定一个单链表，只给出头指针h：</strong><br><strong>1、如何判断是否存在环？</strong><br><strong>2、如何知道环的长度？</strong></p><p>1、对于问题1，使用追赶的方法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。<br>2、对于问题2，记录下问题1的碰撞点p，slow、fast从该点开始，再次碰撞所走过的操作数就是环的长度s。</p><h3 id="设计一种数据结构"><a class="markdownIt-Anchor" href="#设计一种数据结构"></a> 设计一种数据结构</h3><p>满足：push、pop、getLast、getmax</p><h3 id="在单链表中如何用最快的方法找到中间元素"><a class="markdownIt-Anchor" href="#在单链表中如何用最快的方法找到中间元素"></a> 在单链表中如何用最快的方法找到中间元素？</h3><p>快慢指针</p><h3 id="给定一个非空整数数组除了某个元素只出现一次以外其余每个元素均出现两次-找出那个只出现了一次的元素"><a class="markdownIt-Anchor" href="#给定一个非空整数数组除了某个元素只出现一次以外其余每个元素均出现两次-找出那个只出现了一次的元素"></a> 给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</h3><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="题目解析"><a class="markdownIt-Anchor" href="#题目解析"></a> 题目解析</h4><p>根据题目描述，由于加上了时间复杂度必须是 O(n) ，并且空间复杂度为 O(1) 的条件，因此不能用排序方法，也不能使用 map 数据结构。</p><p>程序员小吴想了一下午没想出来，答案是使用 <strong>位操作Bit Operation</strong> 来解此题。</p><p>将所有元素做异或运算，即a[1] ⊕ a[2] ⊕ a[3] ⊕ …⊕ a[n]，所得的结果就是那个只出现一次的数字，时间复杂度为O(n)。</p><h4 id="异或"><a class="markdownIt-Anchor" href="#异或"></a> 异或</h4><p>异或运算A ⊕ B的真值表如下：</p><p>AB⊕FFFFTTTFTTTF</p><h4 id="动画演示"><a class="markdownIt-Anchor" href="#动画演示"></a> 动画演示</h4><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/37c5e38e41ae587b8e4cfb49c6f7e8f4-b2baa9.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/37c5e38e41ae587b8e4cfb49c6f7e8f4-b2baa9.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="有一个-n-个元素的数组除了两个数只出现一次外其余元素都出现两次让你找出这两个只出现一次的数分别是几要求时间复杂度为-on-且再开辟的内存空间固定与-n-无关"><a class="markdownIt-Anchor" href="#有一个-n-个元素的数组除了两个数只出现一次外其余元素都出现两次让你找出这两个只出现一次的数分别是几要求时间复杂度为-on-且再开辟的内存空间固定与-n-无关"></a> 有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。</h3><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例 :</h4><p>输入: [1,2,2,1,3,4]<br>输出: [3,4]</p><h4 id="题目再解析"><a class="markdownIt-Anchor" href="#题目再解析"></a> 题目再解析</h4><p>根据前面找一个不同数的思路算法，在这里把所有元素都异或，那么得到的结果就是那两个只出现一次的元素异或的结果。</p><p>然后，因为这两个只出现一次的元素一定是不相同的，所以这两个元素的二进制形式肯定至少有某一位是不同的，即一个为 0 ，另一个为 1 ，现在需要找到这一位。</p><p>根据异或的性质 <code>任何一个数字异或它自己都等于 0</code>，得到这个数字二进制形式中任意一个为 1 的位都是我们要找的那一位。</p><p>再然后，以这一位是 1 还是 0 为标准，将数组的 n 个元素分成两部分。</p><ul><li>将这一位为 0 的所有元素做异或，得出的数就是只出现一次的数中的一个</li><li>将这一位为 1 的所有元素做异或，得出的数就是只出现一次的数中的另一个。</li></ul><p>这样就解出题目。忽略寻找不同位的过程，总共遍历数组两次，时间复杂度为O(n)。</p><h4 id="动画再演示"><a class="markdownIt-Anchor" href="#动画再演示"></a> 动画再演示</h4><p><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/09/9d14f7004483dd347ddb1b4c9b94cf05-73d7e1.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="两个水杯的问题"><a class="markdownIt-Anchor" href="#两个水杯的问题"></a> 两个水杯的问题</h3><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>有一种玻璃杯从一栋100层的大楼扔下，该种玻璃杯超过某一层楼会摔碎。 现在给你两个杯子，问确定最低摔碎的楼层需要摔多少次？</p><h4 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h4><p>这道题的假设是：最低摔碎的楼层可能是每一层楼，且概率相同。我们需要找一种方法，使得定位到[1-100]之间的任意一个数都是快速的。</p><h4 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h4><p>最简单的方法是用一个杯子从第一层开始，不断一层层的往上试。但是这样的时间复杂度是O(n)。直觉也告诉我们<strong>想放大步子扔</strong>。</p><p>因为我们有两个杯子，可以考虑成一个<code>杯子Cup1</code>不断扔直到破碎，它用来确定最低摔碎的楼层在什么范围，</p><p>另一个<code>杯子Cup2</code>再此基础上一层层的扔。用来准确确定最低摔碎的楼层是多少。如果凭空想象，我们可能会想到二分法，每次隔5个楼层扔，10个楼层扔…</p><p>可是我们马上也应该会想到这么分的不妥之处在于：</p><p>确定最低摔碎的楼层所需次数是不均匀分布的。</p><p>我们再来看：每次扔的楼层间隔会带来什么影响？</p><p>确定最低摔碎的楼层：</p><p><strong>总次数 = Cup1扔的次数 + Cup2扔的次数</strong></p><p>楼层间隔越大，Cup2需要扔的次数越多。</p><p>相同楼层间隔下：最低摔碎的楼层越高，Cup1需要扔的次数越多，Cup2需要扔的次数可认为相同。</p><p>我们的目的其实是需要尽可能保证：不管最低摔碎的楼层是第一层还是第99层，扔的总次数都尽可能一致且减少。</p><p>如果小伙伴有看我上篇文章中LSMT分层步隆过滤器的实现，有没有受到启发？</p><p>这里我们可以使Cup1需要扔的楼层间隔递减，这样可改善高楼层所需Cup1/Cup2扔的次数。</p><p>假设第一次扔的楼层间隔为X，此后依次递减1层，直到楼层间隔为2.则： <strong>x+(x-1)+(x-2)+…+2 &gt;=100</strong></p><p>求解出答案为14。</p><h3 id="如何得到一个数据流中的中位数"><a class="markdownIt-Anchor" href="#如何得到一个数据流中的中位数"></a> 如何得到一个数据流中的中位数？</h3><p>数据是从一个数据流中读出来的，数据的数目随着时间的变化而增加。如果用一个数据容器来保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插入到数据容器中。</p><p>如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>数组</strong>是最简单的容器。如果数组没有排序，可以用 Partition 函数找出数组中的中位数。在没有排序的数组中插入一个数字和找出中位数的时间复杂度是 O(1)和 O(n)。</p><p>我们还可以往数组里插入新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此需要 O(n)时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需要 O(1)时间即可完成。</p><p><strong>排序</strong>的链表时另外一个选择。我们需要 O(n)时间才能在链表中找到合适的位置插入新的数据。如果定义两个指针指向链表的中间结点（如果链表的结点数目是奇数，那么这两个指针指向同一个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的时间效率一样。</p><p><strong>思路：</strong></p><p>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。 因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是O(logn).由于只需O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是O(1).</p><p>接下来考虑用最大堆和最小堆实现的一些细节。首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1（为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中）。还要保证最大堆中里的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照前面分配的规则会把新的数据插入到最小堆中。如果此时新的数据比最大堆中的一些数据要小，怎么办呢？</p><p>可以先把新的数据插入到最大堆中，接着把最大堆中的最大的数字拿出来插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中的所有数字都大于最大堆中的数字。</p><p>当需要把一个数据插入到最大堆中，但这个数据小于最小堆里的一些数据时，这个情形和前面类似。</p><h2 id="编程题"><a class="markdownIt-Anchor" href="#编程题"></a> 编程题</h2><h3 id="协程池"><a class="markdownIt-Anchor" href="#协程池"></a> 协程池</h3><p>原生实现一个协程池<code>package</code>，使用者应能使用该协程池<code>package</code><strong>并发</strong>完成自己输入的一系列<strong>自定义</strong>任务（要求<strong>解耦</strong>，即<strong>协程池本身和自定义任务完全无关</strong>）</p><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例：</h4><p>输入任务列表（以下仅为伪代码，具体任务的数据结构请自行设计）</p><blockquote><p>[(“fibonacci”, 6), (“padovan”, 11), (“js_error_rate”, {“pv”: 30627846, “js_error_num”: 78456})]</p></blockquote><p>使用者应能基于自定义的<code>handler</code>完成并发任务（上述任务分别是<code>斐波那契数列的第n个数</code>、<code>巴都万数列的第n个数</code>、<code>计算js_error率</code>），得到以下输出：</p><blockquote><p>8, 12, 0.002562</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Kevinello</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://kevinello.ltd/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/">http://kevinello.ltd/2022/01/10/面试官初体验/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://kevinello.ltd" target="_blank">Kevinello</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Kubenetes/">Kubenetes</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a></div><div class="post_share"><div class="social-share" data-image="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/10/%E5%B0%8F%E5%88%AE%E5%88%AEScrapy/"><img class="prev-cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110152859.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">小刮刮Scrapy</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/18/Whosbug%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%972/"><img class="next-cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20211018194549.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Whosbug项目日志2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/29/DEM%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" title="DEM项目日志"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/sky5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-29</div><div class="title">DEM项目日志</div></div></a></div><div><a href="/2022/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%BD%E5%AF%86%E8%90%BD%E5%9C%B0%E7%9A%84%E7%BB%8F%E5%8E%86/" title="记一次国密落地的经历"><img class="cover" src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/05/24/Asymmetric_encryption_-colored--86ce94.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-24</div><div class="title">记一次国密落地的经历</div></div></a></div><div><a href="/2020/11/28/K8s-RoadMap/" title="K8s-RoadMap"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/v2-582b2a32df399cc3f40ef62fd099e438_720w.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-28</div><div class="title">K8s-RoadMap</div></div></a></div><div><a href="/2021/01/26/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/" title="Go 并发编程与定时器"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/711.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Go 并发编程与定时器</div></div></a></div><div><a href="/2021/02/07/Go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="Go单例模式"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/sunset3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-07</div><div class="title">Go单例模式</div></div></a></div><div><a href="/2022/06/13/Golang-panic-recover-%E8%AF%A6%E8%A7%A3/" title="Golang panic&recover 详解"><img class="cover" src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/07/05/1-3N1cYeaexHSCofJq9fo3gQ-d27c5c.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-13</div><div class="title">Golang panic&recover 详解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Utterances</span><span class="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/11/myself-e3fde6.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Kevinello</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kevinello"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kevinello" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/23149976" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="mailto:kevinello42@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">基础题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#golang"><span class="toc-number">2.1.</span> <span class="toc-text">Golang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java"><span class="toc-number">2.2.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis"><span class="toc-number">2.3.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.1.</span> <span class="toc-text">产生内存碎片的主要原因：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">2.3.2.</span> <span class="toc-text">如何清理内存碎片？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis%E7%89%88%E6%9C%AC40%E4%BB%A5%E4%B8%8B"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">Redis版本4.0以下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis%E7%89%88%E6%9C%AC40%E4%BB%A5%E4%B8%8A"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">Redis版本4.0以上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.4.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.5.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%89%8B%E6%AE%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">防御手段：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker"><span class="toc-number">2.7.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubenetes"><span class="toc-number">2.8.</span> <span class="toc-text">Kubenetes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E5%9C%BA%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">现场算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%8678"><span class="toc-number">3.1.</span> <span class="toc-text">子集(78)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">题目要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.2.</span> <span class="toc-text">时间要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text">输入输出示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">3.1.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.5.</span> <span class="toc-text">参考代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-k215"><span class="toc-number">3.2.</span> <span class="toc-text">TOP K(215)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">题目要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%A6%81%E6%B1%82-2"><span class="toc-number">3.2.2.</span> <span class="toc-text">时间要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">3.2.3.</span> <span class="toc-text">输入输出示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-2"><span class="toc-number">3.2.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.2.5.</span> <span class="toc-text">参考代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A3%E7%AD%94%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">口答算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E7%8E%AF%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">判断一个链表是否有环，如何找到这个环的起点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">设计一种数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E6%B3%95%E6%89%BE%E5%88%B0%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.</span> <span class="toc-text">在单链表中如何用最快的方法找到中间元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E9%99%A4%E4%BA%86%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E4%BB%A5%E5%A4%96%E5%85%B6%E4%BD%99%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9D%87%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1-%E6%89%BE%E5%87%BA%E9%82%A3%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.4.</span> <span class="toc-text">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.1.</span> <span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-number">4.4.2.</span> <span class="toc-text">异或</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA"><span class="toc-number">4.4.3.</span> <span class="toc-text">动画演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA-n-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E9%99%A4%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E5%A4%96%E5%85%B6%E4%BD%99%E5%85%83%E7%B4%A0%E9%83%BD%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E8%AE%A9%E4%BD%A0%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%88%86%E5%88%AB%E6%98%AF%E5%87%A0%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA-on-%E4%B8%94%E5%86%8D%E5%BC%80%E8%BE%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%9B%BA%E5%AE%9A%E4%B8%8E-n-%E6%97%A0%E5%85%B3"><span class="toc-number">4.5.</span> <span class="toc-text">有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">示例 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%86%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">4.5.2.</span> <span class="toc-text">题目再解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%86%8D%E6%BC%94%E7%A4%BA"><span class="toc-number">4.5.3.</span> <span class="toc-text">动画再演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%B0%B4%E6%9D%AF%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">两个水杯的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">4.6.2.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">4.6.3.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">如何得到一个数据流中的中位数？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">编程题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.1.</span> <span class="toc-text">协程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">示例：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/Golang-panic-recover-%E8%AF%A6%E8%A7%A3/" title="Golang panic&amp;recover 详解"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/07/05/1-3N1cYeaexHSCofJq9fo3gQ-d27c5c.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Golang panic&amp;recover 详解"></a><div class="content"><a class="title" href="/2022/06/13/Golang-panic-recover-%E8%AF%A6%E8%A7%A3/" title="Golang panic&amp;recover 详解">Golang panic&amp;recover 详解</a><time datetime="2022-06-13T11:35:31.000Z" title="发表于 2022-06-13 19:35:31">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/08/%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86%E5%AF%BC%E8%87%B4%E7%9A%84docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/" title="一次磁盘清理导致的docker启动失败"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/07/05/20020320162790-ac19c3.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="一次磁盘清理导致的docker启动失败"></a><div class="content"><a class="title" href="/2022/06/08/%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86%E5%AF%BC%E8%87%B4%E7%9A%84docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/" title="一次磁盘清理导致的docker启动失败">一次磁盘清理导致的docker启动失败</a><time datetime="2022-06-08T11:11:19.000Z" title="发表于 2022-06-08 19:11:19">2022-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%BD%E5%AF%86%E8%90%BD%E5%9C%B0%E7%9A%84%E7%BB%8F%E5%8E%86/" title="记一次国密落地的经历"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/05/24/Asymmetric_encryption_-colored--86ce94.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="记一次国密落地的经历"></a><div class="content"><a class="title" href="/2022/05/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%BD%E5%AF%86%E8%90%BD%E5%9C%B0%E7%9A%84%E7%BB%8F%E5%8E%86/" title="记一次国密落地的经历">记一次国密落地的经历</a><time datetime="2022-05-24T04:59:10.000Z" title="发表于 2022-05-24 12:59:10">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/Distributed-Tracing-in-Grafana-Jaeger-Tempo/" title="Distributed Tracing in Grafana -- Jaeger &amp; Tempo"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/18/image-20220418005500383-8e471f.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Distributed Tracing in Grafana -- Jaeger &amp; Tempo"></a><div class="content"><a class="title" href="/2022/04/18/Distributed-Tracing-in-Grafana-Jaeger-Tempo/" title="Distributed Tracing in Grafana -- Jaeger &amp; Tempo">Distributed Tracing in Grafana -- Jaeger &amp; Tempo</a><time datetime="2022-04-17T16:56:04.000Z" title="发表于 2022-04-18 00:56:04">2022-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/Kevinello%E7%9A%84minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Kevinello的minecraft服务器"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/10/mc-server-1-0fdacc.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Kevinello的minecraft服务器"></a><div class="content"><a class="title" href="/2022/04/11/Kevinello%E7%9A%84minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Kevinello的minecraft服务器">Kevinello的minecraft服务器</a><time datetime="2022-04-10T16:59:10.000Z" title="发表于 2022-04-11 00:59:10">2022-04-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Kevinello</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">🥳 🥳 🥳 🥳 🥳</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/optimized_algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Kevinello/gitalk')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-9gil6as164013b6c',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-9gil6as164013b6c',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Utterances' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>