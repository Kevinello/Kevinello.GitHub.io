<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>从Redis事务到Redis pipeline | Kevinello</title><meta name="keywords" content="数据库,Redis,内存管理"><meta name="author" content="Kevinello"><meta name="copyright" content="Kevinello"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 相信对关系性数据库有使用经验的，都对事务操作很熟悉，为了确保连续多个操作的原子性，我们常用的数据库都会有事务的支持，Redis 也不例外；但它又和关系型数据库支持的事务不太一样  需要了解的几个词  事务：数据库事务通常包含了一个序列的对数据库的读&#x2F;写操作。包含有以下两个目的：  为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法"><meta property="og:type" content="article"><meta property="og:title" content="从Redis事务到Redis pipeline"><meta property="og:url" content="http://kevinello.ltd/2021/04/19/%E4%BB%8ERedis%E4%BA%8B%E5%8A%A1%E5%88%B0Redis-pipeline/index.html"><meta property="og:site_name" content="Kevinello"><meta property="og:description" content="前言 相信对关系性数据库有使用经验的，都对事务操作很熟悉，为了确保连续多个操作的原子性，我们常用的数据库都会有事务的支持，Redis 也不例外；但它又和关系型数据库支持的事务不太一样  需要了解的几个词  事务：数据库事务通常包含了一个序列的对数据库的读&#x2F;写操作。包含有以下两个目的：  为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210406093557.jpg"><meta property="article:published_time" content="2021-04-19T03:15:07.000Z"><meta property="article:modified_time" content="2022-04-09T15:00:30.016Z"><meta property="article:author" content="Kevinello"><meta property="article:tag" content="数据库"><meta property="article:tag" content="Redis"><meta property="article:tag" content="内存管理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210406093557.jpg"><link rel="shortcut icon" href="/imgs/K.jpg"><link rel="canonical" href="http://kevinello.ltd/2021/04/19/%E4%BB%8ERedis%E4%BA%8B%E5%8A%A1%E5%88%B0Redis-pipeline/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d2a20aecba22b2eaf60183c4831d9a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RV8K5FBVX5"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RV8K5FBVX5")</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"13UJR6CRNO","apiKey":"456e56f51ec27a1e13d67bef144f6747","indexName":"Kevinello_blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"从Redis事务到Redis pipeline",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-09 23:00:30"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2232093_k6128tldgy.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/11/myself-e3fde6.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210406093557.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kevinello</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从Redis事务到Redis pipeline</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-19T03:15:07.000Z" title="发表于 2021-04-19 11:15:07">2021-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-09T15:00:30.016Z" title="更新于 2022-04-09 23:00:30">2022-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="从Redis事务到Redis pipeline"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>相信对关系性数据库有使用经验的，都对<strong>事务</strong>操作很熟悉，为了确保连续多个操作的原子性，我们常用的数据库都会有事务的支持，Redis 也不例外；但它又和关系型数据库支持的<strong>事务</strong>不太一样</p><h2 id="需要了解的几个词"><a class="markdownIt-Anchor" href="#需要了解的几个词"></a> 需要了解的几个词</h2><ul><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><strong>事务</strong></a>：数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：<ol><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法</li><li>当多个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91">并发</a>访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰</li></ol></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1#ACID%E6%80%A7%E8%B4%A8">ACID</a>：关系性数据库事务具有的四个特性：<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong>、<strong>持久性（Durability）</strong></li><li>悲观锁(Pessimistic Lock)：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li><li>乐观锁(Optimistic Lock)：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。乐观锁策略：提交版本必须大于记录当前版本才能执行更新</li></ul><h2 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h2><h3 id="基本使用形式"><a class="markdownIt-Anchor" href="#基本使用形式"></a> 基本使用形式</h3><ol><li>MULTI（开启事务）</li><li>一系列命令加入队列</li><li>EXEC（执行事务）/ DISCARD（取消事务）</li></ol><p>Redis 事务可以一次执行多个命令，本质是一组命令的集合；一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</p><p>可以保证一个队列中，一次性、顺序性、排他性的执行一系列命令（Redis 事务的主要作用其实就是串联多个命令防止别的命令插队）</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">MULTI</td><td style="text-align:left">将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态</td></tr><tr><td style="text-align:left">EXEC</td><td style="text-align:left">执行所有事务块内的命令</td></tr><tr><td style="text-align:left">DISCARD</td><td style="text-align:left">取消事务，放弃执行事务块内的所有命令</td></tr><tr><td style="text-align:left">WATCH</td><td style="text-align:left">监视一个（或多个）key，如果在事务执行之前这个（或多个）key被其他命令所改动，那么事务将被打断</td></tr><tr><td style="text-align:left">UNWATCH</td><td style="text-align:left">取消 WATCH 命令对所有 keys 的监视</td></tr></tbody></table><p>如果执行一帆风顺，到这里一切都显得那么合理：</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210418160029.png" alt=""></p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210418160343.png" alt=""></p><p>但在实际的生产环境中往往还会遇到一些问题：</p><ul><li><p>事务在执行 <code>EXEC</code> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误等等，往往是因为调用者没有对参数进行判空处理）</p></li><li><p>命令可能在 <code>EXEC</code> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面</p></li><li><p>OOM / used_memory超过设置的maxmemory（图为redis-server pod挂掉了）</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210418160803.png" alt=""></p></li></ul><p>Redis 针对如上两种错误采用了不同的处理策略，对于发生在 <code>EXEC</code> 执行之前的错误，服务器会对命令入队失败的情况进行记录，并在客户端调用 <code>EXEC</code> 命令时，拒绝执行并自动放弃这个事务（Redis 2.6.5 之前的做法是检查命令入队所得的返回值：如果命令入队时返回 <code>QUEUED</code> ，那么入队成功；否则，就是入队失败）</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210418161319.png" alt=""></p><p>如上图，<code>EXEC</code>前命令入队时出现了语法错误，<code>EXEC</code>时则会直接拒绝该事务</p><p>对于那些在 <code>EXEC</code> 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行</p><p><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210418161447.png" alt=""></p><p>如上图，<code>INCRBY kevinello 1</code>语法没有错误，但<code>kevinello</code>的<code>value</code>是字符串类型，不能对其使用<code>INCRBY</code>；这种情况执行<code>EXEC</code>不会报错，只有那一条命令执行失败</p><p>也就是说<code>Redis</code>是不支持回滚的</p><h2 id="为什么-redis-不支持回滚"><a class="markdownIt-Anchor" href="#为什么-redis-不支持回滚"></a> 为什么 Redis 不支持回滚</h2><p><a target="_blank" rel="noopener" href="https://redislabs.com/blog/you-dont-need-transaction-rollbacks-in-redis/">以下是官方的解释</a>：</p><blockquote><p>This is the moment where one might say that rollbacks would be nice to have. I might agree if not for two considerations:</p><ol><li>The snapshotting mechanism required to implement rollbacks would have a considerable computational cost. That extra complexity wouldn’t sit well with Redis’ philosophy and ecosystem.</li><li>Rollbacks can’t catch all errors. In the example above, we set “counter” to “banana” in order to show a blatant error, but in the real world the process that used the “counter” key in the wrong way might instead have deleted it, or put in a credit-card number, for example. Rollbacks would add a considerable amount of complexity and would still not fully solve the problem.</li></ol><p>The second point is particularly important because it also applies to SQL: SQL DBMSs offer many mechanisms to help protect data integrity, but even they can’t completely protect you from programming errors. <strong>On both platforms, the burden of writing correct transactions remains on you.</strong></p></blockquote><p>翻译一下，两句话：</p><blockquote><ol><li>回滚是非常复杂的操作，不符合Redis的设计哲学和生态系统，且回滚也不能解决所有问题</li><li>需要回滚完全是你们的编程错误导致的，这些错误应该在开发时就被发现，我Redis不背这锅；鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务</li></ol></blockquote><p>其实这篇解释很有意思，其中也多次提到了<code>Redis</code>的设计哲学以及与<code>SQL</code>的对比，感兴趣的同学可以详细阅读（看别人撕逼真有趣）</p><h2 id="基于watch的事务"><a class="markdownIt-Anchor" href="#基于watch的事务"></a> 基于WATCH的事务</h2><blockquote><p>how do you create a transaction that depends on the data present in Redis? For this purpose, Redis implements WATCH, a command for performing optimistic locking.</p><p>如何创建一个依赖于Redis中已存在的数据的事务？ 为此，Redis实现了WATCH，这是用于执行乐观锁的命令</p></blockquote><h3 id="redis实现的乐观锁"><a class="markdownIt-Anchor" href="#redis实现的乐观锁"></a> Redis实现的乐观锁</h3><p><code>WATCH</code> 命令用于在事务开始之前监视任意数量的键： 当调用 <code>EXEC</code> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败</p><p><code>WATCH</code>命令可以被调用多次； 对键的监视从 <code>WATCH</code> 执行之后开始生效， 直到调用 <code>EXEC</code>为止</p><p>当多个<code>Redis</code>客户端尝试使用事务改动同一个被<code>WATCH</code>监视的键时，<code>Redis</code>会自动抛弃某些事务，这时客户端需要重试该事务</p><p><code>WATCH</code>的实现是基于<code>redis</code>中保存的<code>watched_keys</code> 字典实现的，字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端</p><p>具体实现见<a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html?spm=a2c6h.12873639.0.0.59911280BIyHp7#id3">官方文档</a></p><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> Pipeline</h2><blockquote><p>Another way to reduce the latency of Redis queries is by using <a target="_blank" rel="noopener" href="http://redis.io/topics/pipelining">pipelining</a>. When you pipeline a group of operations, they are sent in a single batch that, while bigger and slower to process, requires only a single request-response round trip. This consolidation of trips makes for substantial overall latency reductions.</p></blockquote><p><code>Redis</code>事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 <code>Redis</code>的客户端在执行事务时都会结合 <code>pipeline</code>一起使用，这样可以将多次 IO 操作压缩为单次 IO 操作</p><p>这里基于<code>go-redis</code>客户端实现的<code>pipeline</code>聊一下<code>pipeline</code>的使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">TxPipeline</span><span class="params">()</span> *<span class="title">Pipeline</span></span> &#123;</span><br><span class="line">	pipe := Pipeline&#123;</span><br><span class="line">		exec: c.pipelineExecer(c.txPipelineProcessCmds),</span><br><span class="line">	&#125;</span><br><span class="line">	pipe.cmdable.process = pipe.Process</span><br><span class="line">	pipe.statefulCmdable.process = pipe.Process</span><br><span class="line">	<span class="keyword">return</span> &amp;pipe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>go-redis</code>中实现的事务<code>pipeline</code>，与普通<code>pipeline</code>不同的地方仅在于它的<code>Exec</code>方法，<code>txPipelineProcessCmds</code>中调用了<code>txPipelineWriteMulti</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">txPipelineWriteMulti</span><span class="params">(cn *pool.Conn, cmds []Cmder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	multiExec := <span class="built_in">make</span>([]Cmder, <span class="number">0</span>, <span class="built_in">len</span>(cmds)+<span class="number">2</span>)</span><br><span class="line">	multiExec = <span class="built_in">append</span>(multiExec, NewStatusCmd(<span class="string">&quot;MULTI&quot;</span>))</span><br><span class="line">	multiExec = <span class="built_in">append</span>(multiExec, cmds...)</span><br><span class="line">	multiExec = <span class="built_in">append</span>(multiExec, NewSliceCmd(<span class="string">&quot;EXEC&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> writeCmd(cn, multiExec...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>TxPipeline</code>只是做了一下包装使其支持事务</p><h2 id="pipeline的进阶使用"><a class="markdownIt-Anchor" href="#pipeline的进阶使用"></a> pipeline的进阶使用</h2><p><code>pipeline</code>的基本使用非常简单，但有<a target="_blank" rel="noopener" href="https://redislabs.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/">几点要注意</a>：</p><blockquote><p>Note, however, that a pipeline operation could block your application if it is waiting for replies without sending the pipeline – Redis will provide all of the replies to the pipelined stream of commands only after the pipeline has been sent. Also bear in mind that when using pipelining, Redis caches all the responses in memory before returning them to the client in bulk, so pipelining thousands of queries (especially those that return a large amount of data) can be taxing to both the server and client. If that is the case, use smaller pipeline sizes.</p></blockquote><ul><li>一个<code>pipeline</code>包含的命令不应太多，因为在使用流水线操作时，<code>Redis</code>在将所有响应批量返回给客户端之前会<strong>将所有响应缓存在内存</strong>中，因此对数千个查询（特别是那些返回大量数据的查询）进行流水线操作可能会对服务器和客户端都造成负担</li><li>因为即使是<code>TxPipeline</code>也只是弱事务性的，我们应该在设计业务模型时尽可能保证数据安全性，降低事务出错带来的影响（不要把自己带入基于SQL的设计思维）</li></ul><p>对于第一个问题我们可以简单封装一下<code>TxPipeline</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MaxPipeLineCmdCount = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pipeline *redis.Pipeline</span><br><span class="line">	CmdCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myPipeline *MyPipeline)</span> <span class="title">IncrCmdCount</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	myPipeline.CmdCount++</span><br><span class="line">	<span class="keyword">if</span> myPipeline.CmdCount &gt;= MaxPipeLineCmdCount &#123;</span><br><span class="line">		kutil.Logger.Infof(<span class="string">&quot;myPipeline has %d cmds, will do exec and reset&quot;</span>, MaxPipeLineCmdCount)</span><br><span class="line">		_, err = myPipeline.Pipeline.Exec()</span><br><span class="line">		myPipeline.CmdCount = <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myPipeline *MyPipeline)</span> <span class="title">ClearLeftCmds</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> myPipeline.CmdCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		kutil.Logger.Infof(<span class="string">&quot;myPipeline has %d cmds left, will do exec&quot;</span>, myPipeline.CmdCount)</span><br><span class="line">		_, err = myPipeline.Pipeline.Exec()</span><br><span class="line">		myPipeline.CmdCount = <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kutil.Logger.Infof(<span class="string">&quot;myPipeline has no cmds left&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以采用定时任务的方式检查<code>cmd</code>个数提交<code>pipeline</code></p><h2 id="txpipeline与lua脚本的选择"><a class="markdownIt-Anchor" href="#txpipeline与lua脚本的选择"></a> TxPipeline与Lua脚本的选择</h2><p>官方解释：</p><blockquote><p>There are, in my opinion, a couple of reasonable situations where you might legitimately prefer transactions with optimistic locking over Lua:</p><ol><li>The keys your transaction depends on are not modified frequently, meaning that you are confident optimistic locking will almost never abort transactions.</li><li>You depend on a lot of logic written on the client side—or maybe a third-party service—so there is no easy way to move that logic to a Lua script.</li></ol><p>Unless both these points are true for your application, I recommend you choose Lua over WATCH</p></blockquote><p>值得注意的是官方对比的是带<code>WATCH</code>的事务与Lua脚本</p><p>翻译一下</p><p>只有两种场景下应该使用带<code>WATCH</code>的事务而不是<code>Lua</code>脚本：</p><ul><li>事务依赖的数据并不会被频繁更改，也就是说我们有信心<code>WATCH</code>锁基本不会被打破</li><li>客户端的业务逻辑比较复杂，将其写成<code>Lua</code>脚本的成本较大</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><code>Redis</code>事务仅具有一致性与隔离性，不保证原子性和持久性，所以在设计使用<code>Redis</code>的业务时需要保证数据安全性，在<code>pipeline</code>与<code>Lua</code>脚本的取舍上其实也不用太过纠结，简单的业务可以直接封装成<code>Lua</code>脚本</p><p>在使用<code>pipeline</code>时需要注意监控其命令个数，避免对服务器和客户端造成过大的负担，导致业务延迟乃至于<code>OOM</code></p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li><p><a target="_blank" rel="noopener" href="https://redislabs.com/blog/you-dont-need-transaction-rollbacks-in-redis/">You Don’t Need Transaction Rollbacks in Redis</a></p></li><li><p><a target="_blank" rel="noopener" href="https://redislabs.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/">Redis Running Slowly? Here’s What You Can Do About it</a></p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Kevinello</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://kevinello.ltd/2021/04/19/%E4%BB%8ERedis%E4%BA%8B%E5%8A%A1%E5%88%B0Redis-pipeline/">http://kevinello.ltd/2021/04/19/%E4%BB%8ERedis%E4%BA%8B%E5%8A%A1%E5%88%B0Redis-pipeline/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://kevinello.ltd" target="_blank">Kevinello</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><div class="post_share"><div class="social-share" data-image="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210406093557.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/14/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210508140417.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis分布式锁的基本实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/11/Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E6%B8%85%E7%90%86/"><img class="next-cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210411164926.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis内存碎片的产生与清理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/11/Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E6%B8%85%E7%90%86/" title="Redis内存碎片的产生与清理"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210411164926.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">Redis内存碎片的产生与清理</div></div></a></div><div><a href="/2021/06/14/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/" title="Redis分布式锁的基本实现"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210508140417.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-14</div><div class="title">Redis分布式锁的基本实现</div></div></a></div><div><a href="/2021/02/06/Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis的过期策略&内存淘汰策略"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/street2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-06</div><div class="title">Redis的过期策略&内存淘汰策略</div></div></a></div><div><a href="/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/" title="面试官初体验"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">面试官初体验</div></div></a></div><div><a href="/2020/11/29/DEM%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" title="DEM项目日志"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/sky5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-29</div><div class="title">DEM项目日志</div></div></a></div><div><a href="/2020/12/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="数据库缓存的常用设计模式"><img class="cover" src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/high_floor.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">数据库缓存的常用设计模式</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Utterances</span><span class="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/11/myself-e3fde6.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Kevinello</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kevinello"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kevinello" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/23149976" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="mailto:kevinello42@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AF%8D"><span class="toc-number">2.</span> <span class="toc-text">需要了解的几个词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">基本使用形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-redis-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A"><span class="toc-number">4.</span> <span class="toc-text">为什么 Redis 不支持回滚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Ewatch%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">基于WATCH的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">Redis实现的乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline"><span class="toc-number">6.</span> <span class="toc-text">Pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">pipeline的进阶使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#txpipeline%E4%B8%8Elua%E8%84%9A%E6%9C%AC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">8.</span> <span class="toc-text">TxPipeline与Lua脚本的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/Kevinello%E7%9A%84minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Kevinello的minecraft服务器"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/10/mc-server-1-0fdacc.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Kevinello的minecraft服务器"></a><div class="content"><a class="title" href="/2022/04/11/Kevinello%E7%9A%84minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Kevinello的minecraft服务器">Kevinello的minecraft服务器</a><time datetime="2022-04-10T16:59:10.000Z" title="发表于 2022-04-11 00:59:10">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/Run-minecraft-on-mac-pro-m1/" title="Run minecraft on mac pro m1"><img src="http://kevinello-1302687393.file.myqcloud.com/picgo/2022/04/11/image-20220411004009248-89fe44.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Run minecraft on mac pro m1"></a><div class="content"><a class="title" href="/2022/04/11/Run-minecraft-on-mac-pro-m1/" title="Run minecraft on mac pro m1">Run minecraft on mac pro m1</a><time datetime="2022-04-10T16:12:47.000Z" title="发表于 2022-04-11 00:12:47">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/%E5%B0%8F%E5%88%AE%E5%88%AEScrapy/" title="小刮刮Scrapy"><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110152859.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="小刮刮Scrapy"></a><div class="content"><a class="title" href="/2022/01/10/%E5%B0%8F%E5%88%AE%E5%88%AEScrapy/" title="小刮刮Scrapy">小刮刮Scrapy</a><time datetime="2022-01-10T07:30:10.000Z" title="发表于 2022-01-10 15:30:10">2022-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/" title="面试官初体验"><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20220110130328.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试官初体验"></a><div class="content"><a class="title" href="/2022/01/10/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%88%9D%E4%BD%93%E9%AA%8C/" title="面试官初体验">面试官初体验</a><time datetime="2022-01-10T04:59:10.000Z" title="发表于 2022-01-10 12:59:10">2022-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/18/Whosbug%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%972/" title="Whosbug项目日志2"><img src="https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20211018194549.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Whosbug项目日志2"></a><div class="content"><a class="title" href="/2021/10/18/Whosbug%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%972/" title="Whosbug项目日志2">Whosbug项目日志2</a><time datetime="2021-10-18T11:41:15.000Z" title="发表于 2021-10-18 19:41:15">2021-10-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://kevinello-1302687393.cos.ap-hongkong.myqcloud.com/img/20210406093557.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Kevinello</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Kevinello/gitalk')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-9gil6as164013b6c',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-9gil6as164013b6c',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Utterances' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>